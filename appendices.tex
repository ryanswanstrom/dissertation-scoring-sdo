\documentclass[SDSUThesis.tex]{subfiles} 
\begin{document}

\newpage

%% numbers following sections with A, B, C..
\appendix
\label{appendix}
\begin{center}
APPENDIX\\
\end{center}
\addcontentsline{toc}{section}{APPENDIX}

\section{Detailed Steps of the SDLC}
\label{app:detailedSDLC}

    Often times the SDLC contains more than the 5 basic steps of requirements, design,
    implementation, testing, and  deployment/maintenance.  Those are the high-level
    phases, but many steps are required to complete each phase.  The following list
    provides a more detailed version of what needs to be accomplished in the 
    entire life cycle of software development. These steps do not need 
    to occur in a sequential fashion.

    \begin{easylist}[itemize]
        & Identify the Work/Task/Project
        && Get Initial Idea 
        && Obtain Details
        & Estimate
        && Create an Estimate (What is included? What is the output? days/dollars/hours/reqs)
        && Obtain Approval 
        && Quit or Go Forward
        & Document Requirements
        && Identify the Requirements
        && Detail the Requirements
        & Design The Software
        && Find System Integrations
        && Identify Functional Specs
        && Detail the Functional Specs
        & Development of all the tasks in Design and Requirements
        && Identify the Coding Tasks
        && Write the Code/Develop the solution
        && Write the Unit Tests
        & Test
        && Create Test Plans and Cases
        && Run Test Plans and Cases
        & Deployment
        && Create Deployment Steps
        && Run Deployment Steps
        & Maintenance
        && Capture Bugs
        && Survey Users
        & Start Again
    \end{easylist}

\section{CASE STUDY SOURCE CODE} 
\label{app:case}

%% set appendix to single space for th source code
\linespread{1.0}

%% options for lists
\lstset{ %
  basicstyle=\small,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  commentstyle=\color{ForestGreen},    % comment style
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{gray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  tabsize=4,                       % sets default tabsize to 2 spaces
}

\subsection{SQL CODE - DATA TABLES}
    \lstinputlisting[language=SQL, label=src:rawSQL]{source/raw_tables.sql}

\subsection{SQL CODE - SCORE TABLES}
    \lstinputlisting[language=SQL, label=src:scoreSQL]{source/score_tables.sql}
    
\subsection{SQL CODE - FINAL SCORE TABLES}
    \lstinputlisting[language=SQL, label=src:overallscoreSQL]{source/overall_score_tables.sql}
    
\subsection{R CODE - QUALITY} 
\scriptsize{
\begin{lstlisting}[language=R]
# Load the Quality data.
setAs("character","myDate", function(from) as.Date(from, format="%m/%d/%Y") )
setClass('myDate')

quality_data <- read.csv('quality_data_clean.csv', 
        colClasses=c('factor','myDate','myDate','numeric','numeric',
        'numeric','numeric','numeric','numeric','numeric') )
str(quality_data)
head(quality_data)
summary(quality_data)

# Get data prior to 2013
old_quality_data = quality_data[quality_data$MONTH_DT <= as.Date('2013-12-31') ,]
str(old_quality_data)
pairs(old_quality_data[,c('TOTAL_TIX','EST_DEV_RES_HRS')] )

# Separate out large (>1000 hours) and small projects
large_quality_data = old_quality_data[old_quality_data$EST_DEV_RES_HRS >= 1000,]
str(large_quality_data)
largefit <- lm(TOTAL_TIX ~ EST_DEV_RES_HRS + DFTS_CNT_SIT + DFTS_CNT_UAT , 
        data=large_quality_data)
summary(largefit)
largefit_sigma = summary(largefit)$sigma
pairs(large_quality_data[,c('EST_DEV_RES_HRS','DFTS_CNT_SIT',
        'DFTS_CNT_UAT','TOTAL_TIX')])

small_quality_data = 
        old_quality_data[old_quality_data$EST_DEV_RES_HRS < 1000 
            && old_quality_data$APP != 'App 86' ,]
str(small_quality_data)
smallfit <- lm(TOTAL_TIX ~ EST_DEV_RES_HRS + DFTS_CNT_SIT + DFTS_CNT_UAT , 
        data=small_quality_data)
summary(smallfit)
smallfit_sigma = summary(smallfit)$sigma
pairs(small_quality_data[,c('EST_DEV_RES_HRS','DFTS_CNT_SIT',
        'DFTS_CNT_UAT','TOTAL_TIX')])

# predict new data  
new_large_quality_data = 
        quality_data[quality_data$MONTH_DT > as.Date('2013-12-31') 
            & quality_data$MONTH_DT < as.Date('2014-12-31') 
            & quality_data$EST_DEV_RES_HRS >= 1000,]
new_small_quality_data = 
        quality_data[quality_data$MONTH_DT > as.Date('2013-12-31') 
        & quality_data$MONTH_DT < as.Date('2014-12-31') 
        & quality_data$EST_DEV_RES_HRS < 1000,]
new_large_quality_data$PREDICTION = 
        predict(largefit, newdata=new_large_quality_data)
new_large_quality_data$SCORE = 
        (new_large_quality_data$PREDICTION - new_large_quality_data$TOTAL_TIX)
        / (6 * summary(largefit)$sigma)
new_large_quality_data[,c('APP','MONTH_DT','TOTAL_TIX','PREDICTION', 'SCORE')]

new_small_quality_data$PREDICTION = predict(smallfit, newdata=new_small_quality_data)
new_small_quality_data$SCORE = 
        (new_small_quality_data$PREDICTION - new_small_quality_data$TOTAL_TIX)
        / (6 * summary(smallfit)$sigma)
new_small_quality_data[,c('APP','MONTH_DT','TOTAL_TIX','PREDICTION', 'SCORE')]

#Combine new data  
new_quality_data = rbind(new_large_quality_data, new_small_quality_data)
str(new_quality_data)
summary(new_quality_data)
  
aggregate(SCORE ~ MONTH_DT, new_quality_data, mean)

# TODO include
# numerical summary stats, graphical summaries,
# dist of variables(hist used for guidance), associations among variables
\end{lstlisting}}


\section{ADDITIONAL SDLC DATA NEEDS}

    \subsection{ESTIMATION}
    
    \begin{itemize}
    \item Change to Database Structure  
    \item Modify Database Data    
    \item Create a New Database, number of new databases  
    \item Server Configuration Changes Required   
    \item New Servers Required   
    \item Number of Team Members Involved  
    \item Number of (sub)Systems Involved  
    \item Estimation Date
    \item Number of Days Allowed
    \item List of Other Attributes
    \item Number of Screens Involved 
    \item Actual Value (hours, days, dollars) 
    \end{itemize}
    
    
    \begin{description}
        \item[Estimated Dev Hours] - 
            The number of development hours estimated for a 
            project, this is just developer hours
        \item[Estimated Doc Hours] - 
            The number of documentation hours estimated for a project
        \item[Estimated Test Hours] - 
            The number of testing hours estimated for a project
        \item[Estimated Deployment Hours] - 
            The number of estimated hours required to 
            deploy the project
    \end{description}
    
    \subsection{REQUIREMENTS}
    List of: 
    \begin{description}
      \item[Title] 
      \item[Descrition]
      \item[author]
      \item[projectID]
      \item[date]
      \item[Comments] list of \\
      \begin{description}
        \item[date]
        \item[comment Text]
        \item[author]
      \end{description}
    \end{description}
    
    \subsection{MAINTENANCE (DEFECTS)}
    List of:
    \begin{description}
      \item[Project] 
      \item[Release]
      \item[description]
      \item[date Entered]
      \item[Date fixed]
      \item[Comments] list of \\
      \begin{description}
        \item[date]
        \item[comment Text]
        \item[author]
      \end{description}
    \end{description}
    
    
    
    \subsection{TESTING}
    
    List of:
    \begin{description}
      \item[Project] 
      \item[Release]
      \item[title]
      \item[description]
      \item[author]
      \item[Date Started]
      \item[Date Executed]
      \item[Status (Pending, pass, fail)]
      \item[Comments] list of \\
      \begin{description}
        \item[date]
        \item[comment Text]
        \item[author]
      \end{description}
    \end{description}
    
    \subsection{DEVELOPMENT}
    
    List of Coding Tasks:
    \begin{description}
      \item[Project] 
      \item[Release]
      \item[List of Files]
      \item[author]
      \item[Date Started]
      \item[Completion Date]
      \item[Number of Unit Tests]
      \item[Lines of Code]
      \item[Others] See \cite{Jones2009, Jones2012, Rubin2007, Snipes2013}
    \end{description}
    
    \subsection{IMPLEMENTATION}
    
    List of:
    \begin{description}
      \item[Project] 
      \item[Release]
      \item[date Entered]
      \item[Date Scheduled]
      \item[Date Executed]
      \item[Ordering/Prerequisites]
      \item[Comments] list of \\
      \begin{description}
        \item[date]
        \item[comment Text]
        \item[author]
      \end{description}
    \end{description}

\end{document}